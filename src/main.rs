fn main() {
    let set1 = vec![1, 2, 3, 4, 5];
    let set2 = vec![4, 5, 6, 7];
    let res = intersection2(set1, set2);
    println!("{:?}", res);
}

// Нахождение пересечения двух множеств, метод более эффективный по скорости выполнения, но менее эффективный по памяти
pub fn intersection2(set1: Vec<i32>, set2: Vec<i32>) -> Vec<i32> {
    let n = set1.len();
    let m = set2.len();
    let mut set1 = set1.clone();
    let mut set2 = set2.clone();
    // сортируем значения в множествах по возрастанию
    set1.sort();
    set2.sort();
    let mut res = vec![];
    let mut i = 0;
    let mut j = 0;

    // двигаемся по значениям множеств начиная с первых значений
    while i < n && j < m {
        // если значения равны, добавляем к результату, если они там не содержатся
        if set1[i] == set2[j] {
            if !res.contains(&set1[i]) {
                res.push(set1[i]);
            }
            i += 1;
            j += 1;
        }
        // если значение первого множества меньше чем второго, увеличиваем индекс первого
        else if set1[i] < set2[j] {
            i += 1;
        }
        // если значение второго множества меньше чем первого, увеличиваем индекс второго
        else {
            j += 1;
        }
        // т.е. двигаемся по элементам множества с меньшими значениями до тех пор пока не встретится значение большее либо равное значению другого множества, либо пока не закончатся элементы
    }
    res
}
